#include <iostream>
#include <vector>
#include <sstream>
#include <queue>
#include <unordered_map>
#include <algorithm>
#include <memory> 
#include <limits>

using namespace std;

// --- ìƒíƒœ ë° êµ¬ì¡°ì²´ ì •ì˜ ---

struct StateKey {
    int idx;
    char arr;
    char system; // 'X': ABCD, 'Y': EFGH
    int collectedMask;

    bool operator==(const StateKey& other) const {
        return idx == other.idx && arr == other.arr && system == other.system && collectedMask == other.collectedMask;
    }
};

struct StateKeyHash {
    size_t operator()(const StateKey& k) const {
        size_t h = hash<int>()(k.idx) ^ (hash<char>()(k.arr) << 1) ^ (hash<char>()(k.system) << 2);
        return h ^ (hash<int>()(k.collectedMask) << 3);
    }
};

struct PathNode;
using PathNodePtr = unique_ptr<PathNode>;

struct PathNode {
    StateKey key;
    int drawCount;
    int tenPlusOneCount;
    string action;
    PathNode* parent;

    PathNode(const StateKey& k, int dc, int t11c, const string& act, PathNode* p)
        : key(k), drawCount(dc), tenPlusOneCount(t11c), action(act), parent(p) {
    }
};

// A* ê²€ìƒ‰ì„ ìœ„í•´ Stateì— remainingGoals (h(n)) ì¶”ê°€
struct State {
    int idx;
    char arr;
    char system;
    int collectedMask;
    int totalDraws;     // g(n): ì‹¤ì œ ë¹„ìš©
    int remainingGoals; // h(n): íœ´ë¦¬ìŠ¤í‹± (ë‚¨ì€ ëª©í‘œ ì•„ì´í…œ ìˆ˜)
    PathNode* node;

    bool operator>(const State& other) const {
        // A* ìš°ì„ ìˆœìœ„: f(n) = g(n) + h(n) ì´ ì‘ì€ ìª½ì´ ìš°ì„ 
        int f_cur = totalDraws + remainingGoals;
        int f_other = other.totalDraws + other.remainingGoals;

        if (f_cur != f_other) {
            return f_cur > f_other;
        }
        // f(n)ì´ ê°™ìœ¼ë©´ g(n)ì´ ì‘ì€ ìª½ (ë” ì ê²Œ ë½‘ì€ ìª½)ì„ ìš°ì„ 
        return totalDraws > other.totalDraws;
    }
};

struct PoolTransition {
    int finalIdx;
    char finalArr;
    char finalSystem;
    int collectedMaskDelta;
    vector<string> routeDetail;
};

unordered_map<char, unordered_map<char, unordered_map<int, PoolTransition>>> transitionTable;

// --- ì „ì—­ ë³€ìˆ˜ ë° í—¬í¼ í•¨ìˆ˜ ---

unordered_map<string, int> goalIdx;
unordered_map<char, vector<string>> pools;
vector<string> currentGoalVec;

vector<string> parseItems(const string& line) {
    vector<string> result;
    stringstream ss(line);
    string token;
    while (getline(ss, token, '|')) {
        if (!token.empty()) result.push_back(token);
    }
    return result;
}

inline char flipArr(char a) {
    if (a == 'A') return 'C';
    if (a == 'C') return 'A';
    if (a == 'E') return 'G';
    if (a == 'G') return 'E';
    return a;
}

// ë‚¨ì€ ëª©í‘œ ì•„ì´í…œ ìˆ˜ (h(n)) ê³„ì‚° í•¨ìˆ˜
int countRemainingGoals(int collectedMask, int M) {
    int remaining = 0;
    int goalMaskFull = (1 << M) - 1;
    int missingMask = goalMaskFull ^ collectedMask;

    // ë¹„íŠ¸ ë§ˆìŠ¤í¬ì—ì„œ ì¼œì§„ ë¹„íŠ¸ ìˆ˜ ì„¸ê¸°
    while (missingMask > 0) {
        missingMask &= (missingMask - 1);
        remaining++;
    }
    return remaining;
}

// --- DP í…Œì´ë¸” ì‚¬ì „ ê³„ì‚° ---

void precomputeTransitions() {
    if (!transitionTable.empty()) return;

    // ì‹œìŠ¤í…œ 'X' (ì‹œì‘ A)ì™€ 'Y' (ì‹œì‘ E)
    vector<pair<char, char>> systems = { {'X', 'A'}, {'Y', 'E'} };

    for (const auto& sys_pair : systems) {
        char system_label = sys_pair.first;
        char main_arr = sys_pair.second;
        char other_arr = flipArr(main_arr); // main_arrê°€ Aë©´ C, Eë©´ G

        for (char arr : {main_arr, other_arr}) {
            if (pools.find(arr) == pools.end()) continue;
            const vector<string>& pool = pools[arr];

            for (int startIdx = 0; startIdx < (int)pool.size(); ++startIdx) {
                char tempArr = arr;
                int tempIdx = startIdx;
                vector<string> detail;

                // 10ë²ˆ ì—°ì† ì¼ë°˜ ë½‘ê¸° ì‹œë®¬ë ˆì´ì…˜
                for (int j = 0; j < 10; ++j) {
                    int drawIdx = tempIdx;
                    if (pools.find(tempArr) == pools.end() || drawIdx >= (int)pools[tempArr].size()) break;

                    string it = pools[tempArr][drawIdx];
                    string actionStr = "10+1 ì¤‘ ì¼ë°˜ [" + string(1, tempArr) + "][" + to_string(drawIdx) + "] â†’ íšë“: " + it;
                    detail.push_back(actionStr);

                    // ë°°ì—´ ì „ì´ ê·œì¹™ ì ìš©
                    if (drawIdx - 1 >= 0 && pools[tempArr][drawIdx - 1] == it) {
                        // Main Array(A, E)ì—ì„œ Other Array(C, G)ë¡œ: +1
                        if (tempArr == main_arr) {
                            tempIdx = drawIdx + 1;
                        }
                        // Other Array(C, G)ì—ì„œ Main Array(A, E)ë¡œ: +2 (ìˆ˜ì • ë°˜ì˜)
                        else {
                            tempIdx = drawIdx + 2;
                        }
                        tempArr = flipArr(tempArr);
                    }
                    else {
                        tempIdx = drawIdx + 1;
                    }
                }

                // ìµœì¢… ë°°ì—´ ì „ì´ (10íšŒ ë½‘ê¸° í›„)
                tempIdx += (tempArr == main_arr ? 0 : 1);
                char finalArr = flipArr(tempArr);

                // MaskDeltaëŠ” 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ê³  ë‚˜ì¤‘ì— ê³„ì‚°
                transitionTable[system_label][arr][startIdx] = { tempIdx, finalArr, system_label, 0, detail };
            }
        }
    }
}

// MaskDelta ë° [FIND] ì¬ê³„ì‚°
void calculateMaskDelta() {
    // ... (ê¸°ì¡´ê³¼ ë™ì¼) ...
    for (auto& sys_pair : transitionTable) {
        for (auto& arr_pair : sys_pair.second) {
            for (auto& idx_pair : arr_pair.second) {
                PoolTransition& transition = idx_pair.second;
                int currentMaskDelta = 0;

                vector<string> newRouteDetail;
                for (const string& rawAction : transition.routeDetail) {
                    size_t start = rawAction.find("íšë“: ") + 5;
                    string item = rawAction.substr(start);

                    string newAction = rawAction;

                    if (goalIdx.count(item)) {
                        currentMaskDelta |= (1 << goalIdx[item]);
                        newAction += " [FIND]";
                    }
                    newRouteDetail.push_back(newAction);
                }
                transition.collectedMaskDelta = currentMaskDelta;
                transition.routeDetail = newRouteDetail;
            }
        }
    }
}


// --- A* ë©”ì¸ ë£¨í”„ í•¨ìˆ˜ ---
void runDijkstra(int goalMaskFull) {

    unordered_map<StateKey, int, StateKeyHash> min_cost;
    vector<PathNodePtr> pathNodes;
    priority_queue<State, vector<State>, greater<State>> pq;
    const int INF = numeric_limits<int>::max();
    int M = currentGoalVec.size();

    // ë‘ ê°€ì§€ ì‹œì‘ì  (A, E)ì„ íì— ì¶”ê°€
    vector<pair<char, char>> start_points = { {'A', 'X'}, {'E', 'Y'} };

    for (const auto& start_pair : start_points) {
        char start_arr = start_pair.first;
        char start_system = start_pair.second;

        if (pools.count(start_arr)) {
            StateKey startKey = { 0, start_arr, start_system, 0 };

            pathNodes.push_back(make_unique<PathNode>(
                startKey, 0, 0, "ì‹œì‘ (ë°°ì—´ " + string(1, start_arr) + ")", nullptr
            ));
            PathNode* startNode = pathNodes.back().get();

            min_cost[startKey] = 0;
            // A* ì‹œì‘: totalDraws=0, remainingGoals=M
            pq.push({ 0, start_arr, start_system, 0, 0, M, startNode });
        }
    }

    PathNode* finalNode = nullptr;

    while (!pq.empty()) {
        State cur = pq.top(); pq.pop();

        StateKey curKey = { cur.idx, cur.arr, cur.system, cur.collectedMask };
        if (cur.totalDraws > (min_cost.count(curKey) ? min_cost[curKey] : INF)) continue;

        if (cur.collectedMask == goalMaskFull) {
            finalNode = cur.node;
            break;
        }

        if (cur.arr != 'A' && cur.arr != 'C' && cur.arr != 'E' && cur.arr != 'G') continue;
        if (pools.find(cur.arr) == pools.end() || cur.idx >= (int)pools[cur.arr].size()) continue;

        string curItem = pools[cur.arr][cur.idx];

        // ì‹œìŠ¤í…œ ë©”ì¸ ë°°ì—´ íŒë³„
        char current_main = (cur.system == 'X' ? 'A' : 'E');
        char current_other = flipArr(current_main);

        // --- 1. ì¼ë°˜ ë½‘ê¸° ---
        {
            State next = cur;
            int nextMask = cur.collectedMask;
            bool isGoal = goalIdx.count(curItem);
            if (isGoal) nextMask |= (1 << goalIdx[curItem]);

            int nextDrawCount = cur.node->drawCount + 1;
            int nextTenPlusOneCount = cur.node->tenPlusOneCount;
            int nextTotalDraws = nextDrawCount + nextTenPlusOneCount;

            bool switched = false;

            if (cur.idx - 1 >= 0 && pools[cur.arr][cur.idx - 1] == curItem) {
                // ë°°ì—´ ì „ì´ ê·œì¹™ ì ìš©: A/E -> C/G (+1), C/G -> A/E (+2)
                if (cur.arr == current_main) { // A/Eì—ì„œ ì „ì´
                    next.idx = cur.idx + 1;
                }
                else { // C/Gì—ì„œ ì „ì´ (ìš”ì²­ ë°˜ì˜)
                    next.idx = cur.idx + 2;
                }
                next.arr = flipArr(cur.arr);
                switched = true;
            }
            if (!switched) {
                next.idx = cur.idx + 1;
                next.arr = cur.arr;
            }
            next.collectedMask = nextMask;
            next.totalDraws = nextTotalDraws;

            string actionStr = "ì¼ë°˜ [" + string(1, cur.arr) + "][" + to_string(cur.idx) + "] â†’ íšë“: " + curItem;
            if (isGoal) actionStr += " [FIND]";

            StateKey nextKey = { next.idx, next.arr, next.system, next.collectedMask };
            if (nextTotalDraws < (min_cost.count(nextKey) ? min_cost[nextKey] : INF)) {
                min_cost[nextKey] = nextTotalDraws;

                pathNodes.push_back(make_unique<PathNode>(
                    nextKey, nextDrawCount, nextTenPlusOneCount,
                    actionStr,
                    cur.node
                ));
                PathNode* nextNode = pathNodes.back().get();

                int remaining = countRemainingGoals(nextMask, M);
                pq.push({ next.idx, next.arr, next.system, nextMask, nextTotalDraws, remaining, nextNode });
            }
        }

        // --- 2. 10+1 ë½‘ê¸° (DP í…Œì´ë¸” ì‚¬ìš©) ---
        if (transitionTable.count(cur.system) && transitionTable[cur.system].count(cur.arr) && transitionTable[cur.system][cur.arr].count(cur.idx)) {
            const auto& transition = transitionTable[cur.system][cur.arr][cur.idx];
            int nextMask = cur.collectedMask | transition.collectedMaskDelta;

            char bonusArr;
            if (cur.arr == 'A') bonusArr = 'B';
            else if (cur.arr == 'C') bonusArr = 'D';
            else if (cur.arr == 'E') bonusArr = 'F';
            else bonusArr = 'H';
            int bonusIdx = cur.idx;

            string bonusActionStr = "";
            if (pools.count(bonusArr) && bonusIdx < (int)pools[bonusArr].size()) {
                string bonus = pools[bonusArr][bonusIdx];
                bool isGoal = goalIdx.count(bonus);
                if (isGoal) nextMask |= (1 << goalIdx[bonus]);

                bonusActionStr = "10+1 ë³´ë„ˆìŠ¤ [" + string(1, bonusArr) + "][" + to_string(bonusIdx) + "] â†’ íšë“: " + bonus;
                if (isGoal) bonusActionStr += " [FIND]";
            }

            int nextDrawCount = cur.node->drawCount;
            int nextTenPlusOneCount = cur.node->tenPlusOneCount + 11;
            int nextTotalDraws = nextDrawCount + nextTenPlusOneCount;

            StateKey nextKey = { transition.finalIdx, transition.finalArr, transition.finalSystem, nextMask };

            if (nextTotalDraws < (min_cost.count(nextKey) ? min_cost[nextKey] : INF)) {
                min_cost[nextKey] = nextTotalDraws;

                string combinedAction = "10+1: 11íšŒ ë½‘ê¸°. [" + string(1, cur.arr) + "][" + to_string(cur.idx) + "] ë¶€í„° ì‹œì‘ (ì‹œìŠ¤í…œ " + string(1, cur.system) + ").\n";
                for (const auto& detail : transition.routeDetail) {
                    combinedAction += "  - " + detail + "\n";
                }
                if (!bonusActionStr.empty()) {
                    combinedAction += "  - " + bonusActionStr + "\n";
                }
                combinedAction += " [ë‹¤ìŒ ì‹œìŠ¤í…œ: " + string(1, transition.finalSystem) + ", ë‹¤ìŒ ë°°ì—´: " + string(1, transition.finalArr) + ", ë‹¤ìŒ ì¸ë±ìŠ¤: " + to_string(transition.finalIdx) + "]";

                pathNodes.push_back(make_unique<PathNode>(
                    nextKey, nextDrawCount, nextTenPlusOneCount,
                    combinedAction,
                    cur.node
                ));
                PathNode* nextNode = pathNodes.back().get();

                int remaining = countRemainingGoals(nextMask, M);
                pq.push({ transition.finalIdx, transition.finalArr, transition.finalSystem, nextMask, nextTotalDraws, remaining, nextNode });
            }
        }

        // --- 3. ë…ë¦½ ë°°ì—´ ì‹œìŠ¤í…œ ì „í™˜ (ë¹„ìš© 0) ---
        char target_arr = (cur.system == 'X' ?
            (cur.arr == 'A' ? 'E' : 'G') :
            (cur.arr == 'E' ? 'A' : 'C'));
        char target_system = (cur.system == 'X' ? 'Y' : 'X');

        StateKey nextKey = { cur.idx, target_arr, target_system, cur.collectedMask };

        if (pools.count(target_arr) && cur.idx < (int)pools[target_arr].size()) {
            int nextTotalDraws = cur.totalDraws;

            if (nextTotalDraws < (min_cost.count(nextKey) ? min_cost[nextKey] : INF)) {
                min_cost[nextKey] = nextTotalDraws;

                string actionStr = "ì‹œìŠ¤í…œ ì „í™˜: " + string(1, cur.system) + "â†’" + string(1, target_system) +
                    " [" + string(1, cur.arr) + "][" + to_string(cur.idx) + "] â†’ [" + string(1, target_arr) + "][" + to_string(cur.idx) + "]";

                pathNodes.push_back(make_unique<PathNode>(
                    nextKey, cur.node->drawCount, cur.node->tenPlusOneCount,
                    actionStr,
                    cur.node
                ));
                PathNode* nextNode = pathNodes.back().get();

                // ì‹œìŠ¤í…œ ì „í™˜ì€ ë§ˆìŠ¤í¬ê°€ ë³€í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ remainingGoals ìœ ì§€
                pq.push({ cur.idx, target_arr, target_system, cur.collectedMask, nextTotalDraws, cur.remainingGoals, nextNode });
            }
        }
    }

    // --- ê²°ê³¼ ì¶œë ¥ (ê²½ë¡œ ì—­ì¶”ì ) ---
    cout << "\n========================================\n";
    if (finalNode) {
        vector<string> finalRoute;
        PathNode* current = finalNode;
        int totalDraws = finalNode->drawCount + finalNode->tenPlusOneCount;
        int drawCount = finalNode->drawCount;
        int tenPlusOneCount = finalNode->tenPlusOneCount / 11;

        while (current && current->parent != nullptr) {
            finalRoute.push_back(current->action);
            current = current->parent;
        }
        reverse(finalRoute.begin(), finalRoute.end());

        cout << "ğŸ¯ ëª©í‘œ ì•„ì´í…œ ë°°ì—´: ";
        for (size_t i = 0; i < currentGoalVec.size(); ++i) {
            cout << currentGoalVec[i] << (i == currentGoalVec.size() - 1 ? "" : "|");
        }
        cout << "\n\n";

        cout << "ğŸŒŸ ìµœì†Œ ë½‘ê¸° íšŸìˆ˜: **" << totalDraws << "íšŒ**\n";
        cout << "ì¼ë°˜ ë½‘ê¸°: " << drawCount << "íšŒ | 10+1 ë½‘ê¸°: " << tenPlusOneCount << "íšŒ\n";

        cout << "\n### [ìµœë‹¨ ë½‘ê¸° ê²½ë¡œ ìƒì„¸ ë‚´ì—­]\n";
        for (auto& step : finalRoute) {
            if (step.find("10+1: 11íšŒ ë½‘ê¸°") != string::npos) {
                cout << "--- 10+1 ì‹œì‘ ---\n";
                cout << step;
                cout << "\n--- 10+1 ì¢…ë£Œ ---\n";
            }
            else {
                cout << "- " << step << "\n";
            }
        }

        cout << "\n### [ëª©í‘œ ì•„ì´í…œ ìµœì¢… íšë“ í˜„í™©]\n";
        for (auto& item : currentGoalVec) {
            bool got = (finalNode->key.collectedMask & (1 << goalIdx[item])) != 0;
            cout << (got ? "âœ… " : "âŒ ") << item << "\n";
        }
    }
    else {
        cout << "ğŸš« í•´ë‹¹ ëª©í‘œ ì•„ì´í…œ ë°°ì—´ì„ íšë“í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n";
    }
    cout << "========================================\n";
}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    vector<char> labels = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' };

    // --- 1. ë°°ì—´ ì…ë ¥ (í•œ ë²ˆë§Œ ì‹¤í–‰) ---
    cout << "===== ë°°ì—´ ì…ë ¥ (ì•„ì´í…œì€ '|'ë¡œ êµ¬ë¶„) =====\n";
    for (char label : labels) {
        cout << "ë°°ì—´ " << label << ": ";
        string line; getline(cin, line);
        pools[label] = parseItems(line);
    }

    // DP í…Œì´ë¸” ì‚¬ì „ ê³„ì‚° (ì‹œìŠ¤í…œ X/Y ëª¨ë‘ í¬í•¨)
    precomputeTransitions();

    // --- 2. ëª©í‘œ ì•„ì´í…œ ë°˜ë³µ ì…ë ¥ ë° ì‹¤í–‰ ---
    cout << "\n========================================\n";
    cout << "â­ï¸ ëª©í‘œ ì•„ì´í…œ ì…ë ¥ (ì•„ì´í…œì€ '|'ë¡œ êµ¬ë¶„)\n";
    cout << "   - ë¹ˆ ì¤„ì„ ì…ë ¥í•˜ë©´ í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë©ë‹ˆë‹¤.\n";
    cout << "========================================\n";

    string goalLine;
    while (true) {
        cout << "\nëª©í‘œ ì•„ì´í…œ ì…ë ¥: ";
        if (!getline(cin, goalLine) || goalLine.empty()) {
            break;
        }

        currentGoalVec = parseItems(goalLine);

        goalIdx.clear();
        for (int i = 0; i < (int)currentGoalVec.size(); ++i) goalIdx[currentGoalVec[i]] = i;

        if (currentGoalVec.size() > 31) {
            cout << "âš ï¸ ëª©í‘œ ì•„ì´í…œì€ ìµœëŒ€ 31ê°œê¹Œì§€ë§Œ ì§€ì›ë©ë‹ˆë‹¤. ë‹¤ì‹œ ì…ë ¥í•´ì£¼ì„¸ìš”.\n";
            continue;
        }

        int goalMaskFull = (1 << (int)currentGoalVec.size()) - 1;

        // DP í…Œì´ë¸”ì˜ MaskDelta ë° [FIND] í‘œì‹œë¥¼ í˜„ì¬ ëª©í‘œì— ë§ê²Œ ì¬ê³„ì‚°
        calculateMaskDelta();

        // A* ì‹¤í–‰
        runDijkstra(goalMaskFull);
    }

    cout << "\ní”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.\n";
    return 0;
}
